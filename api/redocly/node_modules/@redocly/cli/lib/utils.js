"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfigAndHandleErrors = exports.isSubdir = exports.exitWithError = exports.printUnusedWarnings = exports.getOutputFileName = exports.printConfigLintTotals = exports.printLintTotals = exports.handleError = exports.pluralize = exports.writeYaml = exports.readYaml = exports.promptUser = exports.saveBundle = exports.dumpBundle = exports.CircularJSONNotSupportedError = exports.langToExt = exports.escapeLanguageName = exports.pathToFilename = exports.printExecutionTime = exports.getExecutionTime = exports.getFallbackApisOrExit = void 0;
const path_1 = require("path");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
const glob = require("glob-promise");
const fs = require("fs");
const readline = require("readline");
const stream_1 = require("stream");
const openapi_core_1 = require("@redocly/openapi-core");
const types_1 = require("./types");
function getFallbackApisOrExit(argsApis, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { apis } = config;
        const shouldFallbackToAllDefinitions = !isNotEmptyArray(argsApis) && apis && Object.keys(apis).length > 0;
        const res = shouldFallbackToAllDefinitions
            ? fallbackToAllDefinitions(apis, config)
            : yield expandGlobsInEntrypoints(argsApis, config);
        const filteredInvalidEntrypoints = res.filter(({ path }) => !isApiPathValid(path));
        if (isNotEmptyArray(filteredInvalidEntrypoints)) {
            for (const { path } of filteredInvalidEntrypoints) {
                process.stderr.write(colorette_1.yellow(`\n ${path_1.relative(process.cwd(), path)} ${colorette_1.red(`does not exist or is invalid. Please provide a valid path. \n\n`)}`));
            }
            process.exit(1);
        }
        return res;
    });
}
exports.getFallbackApisOrExit = getFallbackApisOrExit;
function getConfigDirectory(config) {
    return config.configFile ? path_1.dirname(config.configFile) : process.cwd();
}
function isNotEmptyArray(args) {
    return Array.isArray(args) && !!args.length;
}
function isApiPathValid(apiPath) {
    if (!apiPath.trim()) {
        exitWithError('Path cannot be empty.');
        return;
    }
    return fs.existsSync(apiPath) || openapi_core_1.isAbsoluteUrl(apiPath) ? apiPath : undefined;
}
function fallbackToAllDefinitions(apis, config) {
    return Object.entries(apis).map(([alias, { root }]) => ({
        path: openapi_core_1.isAbsoluteUrl(root) ? root : path_1.resolve(getConfigDirectory(config), root),
        alias,
    }));
}
function getAliasOrPath(config, aliasOrPath) {
    var _a, _b, _c;
    return config.apis[aliasOrPath]
        ? { path: (_a = config.apis[aliasOrPath]) === null || _a === void 0 ? void 0 : _a.root, alias: aliasOrPath }
        : {
            path: aliasOrPath,
            // find alias by path, take the first match
            alias: (_c = (_b = Object.entries(config.apis).find(([_alias, api]) => {
                return path_1.resolve(api.root) === path_1.resolve(aliasOrPath);
            })) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : undefined,
        };
}
function expandGlobsInEntrypoints(args, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield Promise.all(args.map((aliasOrPath) => __awaiter(this, void 0, void 0, function* () {
            return glob.hasMagic(aliasOrPath) && !openapi_core_1.isAbsoluteUrl(aliasOrPath)
                ? (yield glob(aliasOrPath)).map((g) => getAliasOrPath(config, g))
                : getAliasOrPath(config, aliasOrPath);
        })))).flat();
    });
}
function getExecutionTime(startedAt) {
    return process.env.NODE_ENV === 'test'
        ? '<test>ms'
        : `${Math.ceil(perf_hooks_1.performance.now() - startedAt)}ms`;
}
exports.getExecutionTime = getExecutionTime;
function printExecutionTime(commandName, startedAt, api) {
    const elapsed = getExecutionTime(startedAt);
    process.stderr.write(colorette_1.gray(`\n${api}: ${commandName} processed in ${elapsed}\n\n`));
}
exports.printExecutionTime = printExecutionTime;
function pathToFilename(path, pathSeparator) {
    return path
        .replace(/~1/g, '/')
        .replace(/~0/g, '~')
        .replace(/^\//, '')
        .replace(/\//g, pathSeparator);
}
exports.pathToFilename = pathToFilename;
function escapeLanguageName(lang) {
    return lang.replace(/#/g, '_sharp').replace(/\//, '_').replace(/\s/g, '');
}
exports.escapeLanguageName = escapeLanguageName;
function langToExt(lang) {
    const langObj = {
        php: '.php',
        'c#': '.cs',
        shell: '.sh',
        curl: '.sh',
        bash: '.sh',
        javascript: '.js',
        js: '.js',
        python: '.py',
    };
    return langObj[lang.toLowerCase()];
}
exports.langToExt = langToExt;
class CircularJSONNotSupportedError extends Error {
    constructor(originalError) {
        super(originalError.message);
        this.originalError = originalError;
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, CircularJSONNotSupportedError.prototype);
    }
}
exports.CircularJSONNotSupportedError = CircularJSONNotSupportedError;
function dumpBundle(obj, format, dereference) {
    if (format === 'json') {
        try {
            return JSON.stringify(obj, null, 2);
        }
        catch (e) {
            if (e.message.indexOf('circular') > -1) {
                throw new CircularJSONNotSupportedError(e);
            }
            throw e;
        }
    }
    else {
        return openapi_core_1.stringifyYaml(obj, {
            noRefs: !dereference,
            lineWidth: -1,
        });
    }
}
exports.dumpBundle = dumpBundle;
function saveBundle(filename, output) {
    fs.mkdirSync(path_1.dirname(filename), { recursive: true });
    fs.writeFileSync(filename, output);
}
exports.saveBundle = saveBundle;
function promptUser(query, hideUserInput = false) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            let output = process.stdout;
            let isOutputMuted = false;
            if (hideUserInput) {
                output = new stream_1.Writable({
                    write: (chunk, encoding, callback) => {
                        if (!isOutputMuted) {
                            process.stdout.write(chunk, encoding);
                        }
                        callback();
                    },
                });
            }
            const rl = readline.createInterface({
                input: process.stdin,
                output,
                terminal: true,
                historySize: hideUserInput ? 0 : 30,
            });
            rl.question(`${query}:\n\n  `, (answer) => {
                rl.close();
                resolve(answer);
            });
            isOutputMuted = hideUserInput;
        });
    });
}
exports.promptUser = promptUser;
function readYaml(filename) {
    return openapi_core_1.parseYaml(fs.readFileSync(filename, 'utf-8'), { filename });
}
exports.readYaml = readYaml;
function writeYaml(data, filename, noRefs = false) {
    const content = openapi_core_1.stringifyYaml(data, { noRefs });
    if (process.env.NODE_ENV === 'test') {
        process.stderr.write(content);
        return;
    }
    fs.mkdirSync(path_1.dirname(filename), { recursive: true });
    fs.writeFileSync(filename, content);
}
exports.writeYaml = writeYaml;
function pluralize(label, num) {
    if (label.endsWith('is')) {
        [label] = label.split(' ');
        return num === 1 ? `${label} is` : `${label}s are`;
    }
    return num === 1 ? `${label}` : `${label}s`;
}
exports.pluralize = pluralize;
function handleError(e, ref) {
    if (e instanceof openapi_core_1.ResolveError) {
        process.stderr.write(`Failed to resolve api definition at ${ref}:\n\n  - ${e.message}.\n\n`);
    }
    else if (e instanceof openapi_core_1.YamlParseError) {
        process.stderr.write(`Failed to parse api definition at ${ref}:\n\n  - ${e.message}.\n\n`);
        // TODO: codeframe
    }
    else {
        if (e instanceof CircularJSONNotSupportedError) {
            process.stderr.write(colorette_1.red(`Detected circular reference which can't be converted to JSON.\n`) +
                `Try to use ${colorette_1.blue('yaml')} output or remove ${colorette_1.blue('--dereferenced')}.\n\n`);
        }
        else {
            process.stderr.write(`Something went wrong when processing ${ref}:\n\n  - ${e.message}.\n\n`);
        }
    }
    process.exitCode = 1;
    throw e;
}
exports.handleError = handleError;
function printLintTotals(totals, definitionsCount) {
    const ignored = totals.ignored
        ? colorette_1.yellow(`${totals.ignored} ${pluralize('problem is', totals.ignored)} explicitly ignored.\n\n`)
        : '';
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.red(`❌ Validation failed with ${totals.errors} ${pluralize('error', totals.errors)}${totals.warnings > 0
            ? ` and ${totals.warnings} ${pluralize('warning', totals.warnings)}`
            : ''}.\n${ignored}`));
    }
    else if (totals.warnings > 0) {
        process.stderr.write(colorette_1.green(`Woohoo! Your OpenAPI ${pluralize('definition is', definitionsCount)} valid. 🎉\n`));
        process.stderr.write(colorette_1.yellow(`You have ${totals.warnings} ${pluralize('warning', totals.warnings)}.\n${ignored}`));
    }
    else {
        process.stderr.write(colorette_1.green(`Woohoo! Your OpenAPI ${pluralize('definition is', definitionsCount)} valid. 🎉\n${ignored}`));
    }
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.gray(`run \`openapi lint --generate-ignore-file\` to add all problems to the ignore file.\n`));
    }
    process.stderr.write('\n');
}
exports.printLintTotals = printLintTotals;
function printConfigLintTotals(totals) {
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.red(`❌ Your config has ${totals.errors} ${pluralize('error', totals.errors)}${totals.warnings > 0
            ? ` and ${totals.warnings} ${pluralize('warning', totals.warnings)}`
            : ''}.\n`));
    }
    else if (totals.warnings > 0) {
        process.stderr.write(colorette_1.yellow(`You have ${totals.warnings} ${pluralize('warning', totals.warnings)}.\n`));
    }
}
exports.printConfigLintTotals = printConfigLintTotals;
function getOutputFileName(entrypoint, entries, output, ext) {
    if (!output) {
        return { outputFile: 'stdout', ext: ext || 'yaml' };
    }
    let outputFile = output;
    if (entries > 1) {
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!types_1.outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(output, path_1.basename(entrypoint, path_1.extname(entrypoint))) + '.' + ext;
    }
    else {
        if (output) {
            ext = ext || path_1.extname(output).substring(1);
        }
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!types_1.outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(path_1.dirname(outputFile), path_1.basename(outputFile, path_1.extname(outputFile))) + '.' + ext;
    }
    return { outputFile, ext };
}
exports.getOutputFileName = getOutputFileName;
function printUnusedWarnings(config) {
    const { preprocessors, rules, decorators } = config.getUnusedRules();
    if (rules.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused rules found in ${colorette_1.blue(config.configFile || '')}: ${rules.join(', ')}.\n`));
    }
    if (preprocessors.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused preprocessors found in ${colorette_1.blue(config.configFile || '')}: ${preprocessors.join(', ')}.\n`));
    }
    if (decorators.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused decorators found in ${colorette_1.blue(config.configFile || '')}: ${decorators.join(', ')}.\n`));
    }
    if (rules.length || preprocessors.length) {
        process.stderr.write(`Check the spelling and verify the added plugin prefix.\n`);
    }
}
exports.printUnusedWarnings = printUnusedWarnings;
function exitWithError(message) {
    process.stderr.write(colorette_1.red(message) + '\n\n');
    process.exit(1);
}
exports.exitWithError = exitWithError;
/**
 * Checks if dir is subdir of parent
 */
function isSubdir(parent, dir) {
    const relativePath = path_1.relative(parent, dir);
    return !!relativePath && !/^..($|\/)/.test(relativePath) && !path_1.isAbsolute(relativePath);
}
exports.isSubdir = isSubdir;
function loadConfigAndHandleErrors(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield openapi_core_1.loadConfig(options);
        }
        catch (e) {
            exitWithError(e.message);
            return new openapi_core_1.Config({ apis: {}, styleguide: {} });
        }
    });
}
exports.loadConfigAndHandleErrors = loadConfigAndHandleErrors;
