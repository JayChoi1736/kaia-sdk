"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiRoot = exports.transformPush = exports.getDestinationProps = exports.handlePush = void 0;
const fs = require("fs");
const path = require("path");
const node_fetch_1 = require("node-fetch");
const perf_hooks_1 = require("perf_hooks");
const colorette_1 = require("colorette");
const crypto_1 = require("crypto");
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const login_1 = require("./login");
const DEFAULT_VERSION = 'latest';
const DESTINATION_REGEX = /^(@(?<organizationId>[\w\-\s]+)\/)?(?<name>[^@]*)@(?<version>[\w\.\-]+)$/;
function handlePush(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield utils_1.loadConfigAndHandleErrors({ region: argv.region, files: argv.files });
        const client = new openapi_core_1.RedoclyClient(config.region);
        const isAuthorized = yield client.isAuthorizedWithRedoclyByRegion();
        if (!isAuthorized) {
            const clientToken = yield login_1.promptClientToken(client.domain);
            yield client.login(clientToken);
        }
        const startedAt = perf_hooks_1.performance.now();
        const { destination, branchName, upsert } = argv;
        const batchId = argv['batch-id'];
        const batchSize = argv['batch-size'];
        if (destination && !DESTINATION_REGEX.test(destination)) {
            utils_1.exitWithError(`Destination argument value is not valid, please use the right format: ${colorette_1.yellow('<@organization-id/api-name@api-version>')}`);
        }
        const { organizationId, name, version } = getDestinationProps(destination, config.organization);
        if (!organizationId) {
            return utils_1.exitWithError(`No organization provided, please use the right format: ${colorette_1.yellow('<@organization-id/api-name@api-version>')} or specify the 'organization' field in the config file.`);
        }
        const api = argv.api || (name && version && getApiRoot({ name, version, config }));
        if (name && version && !api) {
            utils_1.exitWithError(`No api found that matches ${colorette_1.blue(`${name}@${version}`)}. Please make sure you have provided the correct data in the config file.`);
        }
        if (batchId && !batchId.trim()) {
            utils_1.exitWithError(`The ${colorette_1.blue(`batch-id`)} option value is not valid, please avoid using an empty string.`);
        }
        if (batchSize && batchSize < 2) {
            utils_1.exitWithError(`The ${colorette_1.blue(`batch-size`)} option value is not valid, please use the integer bigger than 1.`);
        }
        const apis = api ? { [`${name}@${version}`]: { root: api } } : config.apis;
        if (!Object.keys(apis).length) {
            utils_1.exitWithError(`Api not found. Please make sure you have provided the correct data in the config file.`);
        }
        for (const [apiNameAndVersion, { root: api }] of Object.entries(apis)) {
            const resolvedConfig = openapi_core_1.getMergedConfig(config, apiNameAndVersion);
            resolvedConfig.styleguide.skipDecorators(argv['skip-decorator']);
            const [name, version = DEFAULT_VERSION] = apiNameAndVersion.split('@');
            try {
                let rootFilePath = '';
                const filePaths = [];
                const filesToUpload = yield collectFilesToUpload(api, resolvedConfig);
                const filesHash = hashFiles(filesToUpload.files);
                process.stdout.write(`Uploading ${filesToUpload.files.length} ${utils_1.pluralize('file', filesToUpload.files.length)}:\n`);
                let uploaded = 0;
                for (const file of filesToUpload.files) {
                    const { signedUploadUrl, filePath } = yield client.registryApi.prepareFileUpload({
                        organizationId,
                        name,
                        version,
                        filesHash,
                        filename: file.keyOnS3,
                        isUpsert: upsert,
                    });
                    if (file.filePath === filesToUpload.root) {
                        rootFilePath = filePath;
                    }
                    filePaths.push(filePath);
                    process.stdout.write(`Uploading ${file.contents ? 'bundle for ' : ''}${colorette_1.blue(file.filePath)}...`);
                    const uploadResponse = yield uploadFileToS3(signedUploadUrl, file.contents || file.filePath);
                    const fileCounter = `(${++uploaded}/${filesToUpload.files.length})`;
                    if (!uploadResponse.ok) {
                        utils_1.exitWithError(`✗ ${fileCounter}\nFile upload failed\n`);
                    }
                    process.stdout.write(colorette_1.green(`✓ ${fileCounter}\n`));
                }
                process.stdout.write('\n');
                yield client.registryApi.pushApi({
                    organizationId,
                    name,
                    version,
                    rootFilePath,
                    filePaths,
                    branch: branchName,
                    isUpsert: upsert,
                    isPublic: argv['public'],
                    batchId: batchId,
                    batchSize: batchSize,
                });
            }
            catch (error) {
                if (error.message === 'ORGANIZATION_NOT_FOUND') {
                    utils_1.exitWithError(`Organization ${colorette_1.blue(organizationId)} not found`);
                }
                if (error.message === 'API_VERSION_NOT_FOUND') {
                    utils_1.exitWithError(`The definition version ${colorette_1.blue(name)}/${colorette_1.blue(version)} does not exist in organization ${colorette_1.blue(organizationId)}!\n${colorette_1.yellow('Suggestion:')} please use ${colorette_1.blue('-u')} or ${colorette_1.blue('--upsert')} to create definition.
        `);
                }
                throw error;
            }
            process.stdout.write(`Definition: ${colorette_1.blue(api)} is successfully pushed to Redocly API Registry \n`);
        }
        utils_1.printExecutionTime('push', startedAt, api || `apis in organization ${organizationId}`);
    });
}
exports.handlePush = handlePush;
function getFilesList(dir, files) {
    files = files || [];
    const filesAndDirs = fs.readdirSync(dir);
    for (const name of filesAndDirs) {
        if (fs.statSync(path.join(dir, name)).isDirectory()) {
            files = getFilesList(path.join(dir, name), files);
        }
        else {
            const currentPath = dir + '/' + name;
            files.push(currentPath);
        }
    }
    return files;
}
function collectFilesToUpload(api, config) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const files = [];
        const [{ path: apiPath }] = yield utils_1.getFallbackApisOrExit([api], config);
        process.stdout.write('Bundling definition\n');
        const { bundle: openapiBundle, problems } = yield openapi_core_1.bundle({
            config,
            ref: apiPath,
            skipRedoclyRegistryRefs: true,
        });
        const fileTotals = openapi_core_1.getTotals(problems);
        if (fileTotals.errors === 0) {
            process.stdout.write(`Created a bundle for ${colorette_1.blue(api)} ${fileTotals.warnings > 0 ? 'with warnings' : ''}\n`);
        }
        else {
            utils_1.exitWithError(`Failed to create a bundle for ${colorette_1.blue(api)}\n`);
        }
        const fileExt = path.extname(apiPath).split('.').pop();
        files.push(getFileEntry(apiPath, utils_1.dumpBundle(openapiBundle.parsed, fileExt)));
        if (fs.existsSync('package.json')) {
            files.push(getFileEntry('package.json'));
        }
        if (fs.existsSync(openapi_core_1.IGNORE_FILE)) {
            files.push(getFileEntry(openapi_core_1.IGNORE_FILE));
        }
        if (config.configFile) {
            // All config file paths including the root one
            files.push(...[...new Set(config.styleguide.extendPaths)].map((f) => getFileEntry(f)));
            if ((_b = (_a = config.theme) === null || _a === void 0 ? void 0 : _a.openapi) === null || _b === void 0 ? void 0 : _b.htmlTemplate) {
                const dir = getFolder(config.theme.openapi.htmlTemplate);
                const fileList = getFilesList(dir, []);
                files.push(...fileList.map((f) => getFileEntry(f)));
            }
            const pluginFiles = new Set();
            for (const plugin of config.styleguide.pluginPaths) {
                if (typeof plugin !== 'string')
                    continue;
                const fileList = getFilesList(getFolder(plugin), []);
                fileList.forEach((f) => pluginFiles.add(f));
            }
            files.push(...filterPluginFilesByExt(Array.from(pluginFiles)).map((f) => getFileEntry(f)));
        }
        if (config.files) {
            const otherFiles = new Set();
            for (const file of config.files) {
                if (fs.statSync(file).isDirectory()) {
                    const fileList = getFilesList(file, []);
                    fileList.forEach((f) => otherFiles.add(f));
                }
                else {
                    otherFiles.add(file);
                }
            }
            files.push(...Array.from(otherFiles).map((f) => getFileEntry(f)));
        }
        return {
            files,
            root: path.resolve(apiPath),
        };
        function filterPluginFilesByExt(files) {
            return files.filter((file) => {
                const fileExt = path.extname(file).toLowerCase();
                return fileExt === '.js' || fileExt === '.ts' || fileExt === '.mjs' || fileExt === 'json';
            });
        }
        function getFileEntry(filename, contents) {
            return {
                filePath: path.resolve(filename),
                keyOnS3: config.configFile
                    ? openapi_core_1.slash(path.relative(path.dirname(config.configFile), filename))
                    : openapi_core_1.slash(path.basename(filename)),
                contents: (contents && Buffer.from(contents, 'utf-8')) || undefined,
            };
        }
    });
}
function getFolder(filePath) {
    return path.resolve(path.dirname(filePath));
}
function hashFiles(filePaths) {
    const sum = crypto_1.createHash('sha256');
    filePaths.forEach((file) => sum.update(fs.readFileSync(file.filePath)));
    return sum.digest('hex');
}
function parseDestination(destination) {
    var _a;
    return (_a = destination === null || destination === void 0 ? void 0 : destination.match(DESTINATION_REGEX)) === null || _a === void 0 ? void 0 : _a.groups;
}
function getDestinationProps(destination, organization) {
    const groups = destination && parseDestination(destination);
    if (groups) {
        groups.name && (groups.name = encodeURIComponent(groups.name));
        return {
            organizationId: groups.organizationId || organization,
            name: groups.name,
            version: groups.version,
        };
    }
    else {
        return { organizationId: organization, name: undefined, version: undefined };
    }
}
exports.getDestinationProps = getDestinationProps;
const transformPush = (callback) => (_a) => {
    var { maybeApiOrDestination, maybeDestination, maybeBranchName, branch } = _a, rest = __rest(_a, ["maybeApiOrDestination", "maybeDestination", "maybeBranchName", "branch"]);
    if (maybeBranchName) {
        process.stderr.write(colorette_1.yellow('Deprecation warning: Do not use the third parameter as a branch name. Please use a separate --branch option instead.'));
    }
    const api = maybeDestination ? maybeApiOrDestination : undefined;
    const destination = maybeDestination || maybeApiOrDestination;
    return callback(Object.assign(Object.assign({}, rest), { destination,
        api, branchName: branch !== null && branch !== void 0 ? branch : maybeBranchName }));
};
exports.transformPush = transformPush;
function getApiRoot({ name, version, config: { apis }, }) {
    const api = (apis === null || apis === void 0 ? void 0 : apis[`${name}@${version}`]) || (version === DEFAULT_VERSION && (apis === null || apis === void 0 ? void 0 : apis[name]));
    return api === null || api === void 0 ? void 0 : api.root;
}
exports.getApiRoot = getApiRoot;
function uploadFileToS3(url, filePathOrBuffer) {
    const fileSizeInBytes = typeof filePathOrBuffer === 'string'
        ? fs.statSync(filePathOrBuffer).size
        : filePathOrBuffer.byteLength;
    const readStream = typeof filePathOrBuffer === 'string' ? fs.createReadStream(filePathOrBuffer) : filePathOrBuffer;
    return node_fetch_1.default(url, {
        method: 'PUT',
        headers: {
            'Content-Length': fileSizeInBytes.toString(),
        },
        body: readStream,
    });
}
