"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const openapi_core_1 = require("@redocly/openapi-core");
const colorette_1 = require("colorette");
const fs_1 = require("fs");
const path = require("path");
jest.mock('os');
jest.mock('colorette');
jest.mock('fs');
describe('isSubdir', () => {
    it('can correctly determine if subdir', () => {
        [
            ['/foo', '/foo', false],
            ['/foo', '/bar', false],
            ['/foo', '/foobar', false],
            ['/foo', '/foo/bar', true],
            ['/foo', '/foo/../bar', false],
            ['/foo', '/foo/./bar', true],
            ['/bar/../foo', '/foo/bar', true],
            ['/foo', './bar', false],
            ['/foo', '/foo/..bar', true],
        ].forEach(([parent, child, expectRes]) => {
            expect(utils_1.isSubdir(parent, child)).toBe(expectRes);
        });
    });
    it('can correctly determine if subdir for windows-based paths', () => {
        const os = require('os');
        os.platform.mockImplementation(() => 'win32');
        [
            ['C:/Foo', 'C:/Foo/Bar', true],
            ['C:\\Foo', 'C:\\Bar', false],
            ['C:\\Foo', 'D:\\Foo\\Bar', false],
        ].forEach(([parent, child, expectRes]) => {
            expect(utils_1.isSubdir(parent, child)).toBe(expectRes);
        });
    });
    afterEach(() => {
        jest.resetModules();
    });
});
describe('pathToFilename', () => {
    it('should use correct path separator', () => {
        const processedPath = utils_1.pathToFilename('/user/createWithList', '_');
        expect(processedPath).toEqual('user_createWithList');
    });
});
describe('getFallbackApisOrExit', () => {
    it('should find alias by filename', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => true);
        const entry = yield utils_1.getFallbackApisOrExit(['./test.yaml'], {
            apis: {
                main: {
                    root: 'test.yaml',
                },
            },
        });
        expect(entry).toEqual([{ path: './test.yaml', alias: 'main' }]);
    }));
});
describe('printConfigLintTotals', () => {
    const totalProblemsMock = {
        errors: 1,
        warnings: 0,
        ignored: 0,
    };
    const redColoretteMocks = colorette_1.red;
    const yellowColoretteMocks = colorette_1.yellow;
    beforeEach(() => {
        yellowColoretteMocks.mockImplementation((text) => text);
        redColoretteMocks.mockImplementation((text) => text);
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
    });
    it('should print errors if such exist', () => {
        utils_1.printConfigLintTotals(totalProblemsMock);
        expect(process.stderr.write).toHaveBeenCalledWith('❌ Your config has 1 error.\n');
        expect(redColoretteMocks).toHaveBeenCalledWith('❌ Your config has 1 error.\n');
    });
    it('should print warnign and error', () => {
        utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { warnings: 2 }));
        expect(process.stderr.write).toHaveBeenCalledWith('❌ Your config has 1 error and 2 warnings.\n');
        expect(redColoretteMocks).toHaveBeenCalledWith('❌ Your config has 1 error and 2 warnings.\n');
    });
    it('should print warnign if no error', () => {
        utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { errors: 0, warnings: 2 }));
        expect(process.stderr.write).toHaveBeenCalledWith('You have 2 warnings.\n');
        expect(yellowColoretteMocks).toHaveBeenCalledWith('You have 2 warnings.\n');
    });
    it('should print nothing if no error and no warnings', () => {
        const result = utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { errors: 0 }));
        expect(result).toBeUndefined();
        expect(process.stderr.write).toHaveBeenCalledTimes(0);
        expect(yellowColoretteMocks).toHaveBeenCalledTimes(0);
        expect(redColoretteMocks).toHaveBeenCalledTimes(0);
    });
});
describe('getFallbackApisOrExit', () => {
    const redColoretteMocks = colorette_1.red;
    const yellowColoretteMocks = colorette_1.yellow;
    const apis = {
        main: {
            root: 'someFile.yaml',
            styleguide: {},
        },
    };
    const config = { apis };
    beforeEach(() => {
        yellowColoretteMocks.mockImplementation((text) => text);
        redColoretteMocks.mockImplementation((text) => text);
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
        jest.spyOn(process, 'exit').mockImplementation();
    });
    it('should exit with error because no path provided', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisConfig = {
            apis: {},
        };
        yield utils_1.getFallbackApisOrExit([''], apisConfig);
        expect(process.exit).toHaveBeenCalledWith(1);
    }));
    it('should error if file from config do not exist', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => false);
        yield utils_1.getFallbackApisOrExit(undefined, config);
        expect(process.stderr.write).toHaveBeenCalledWith('\n someFile.yaml does not exist or is invalid. Please provide a valid path. \n\n');
        expect(process.exit).toHaveBeenCalledWith(1);
    }));
    it('should return valid array with results if such file exist', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => true);
        jest.spyOn(path, 'resolve').mockImplementationOnce((_, path) => path);
        const result = yield utils_1.getFallbackApisOrExit(undefined, config);
        expect(process.stderr.write).toHaveBeenCalledTimes(0);
        expect(process.exit).toHaveBeenCalledTimes(0);
        expect(result).toStrictEqual([
            {
                alias: 'main',
                path: 'someFile.yaml',
            },
        ]);
    }));
    it('should exit with error in case if invalid path provided as args', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisConfig = {
            apis: {},
        };
        fs_1.existsSync.mockImplementationOnce(() => false);
        yield utils_1.getFallbackApisOrExit(['someFile.yaml'], apisConfig);
        expect(process.stderr.write).toHaveBeenCalledWith('\n someFile.yaml does not exist or is invalid. Please provide a valid path. \n\n');
        expect(process.exit).toHaveBeenCalledWith(1);
    }));
    it('should exit with error in case if invalid 2 path provided as args', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisConfig = {
            apis: {},
        };
        fs_1.existsSync.mockImplementationOnce(() => false);
        yield utils_1.getFallbackApisOrExit(['someFile.yaml', 'someFile2.yaml'], apisConfig);
        expect(process.stderr.write).lastCalledWith('\n someFile2.yaml does not exist or is invalid. Please provide a valid path. \n\n');
        expect(process.exit).toHaveBeenCalledWith(1);
    }));
    it('should exit with error if only one file exist ', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisStub = Object.assign(Object.assign({}, apis), { notExist: {
                root: 'notExist.yaml',
                styleguide: {},
            } });
        const configStub = { apis: apisStub };
        fs_1.existsSync.mockImplementationOnce((path) => path === 'someFile.yaml');
        yield utils_1.getFallbackApisOrExit(undefined, configStub);
        expect(process.stderr.write).toBeCalledWith('\n notExist.yaml does not exist or is invalid. Please provide a valid path. \n\n');
        expect(process.exit).toHaveBeenCalledWith(1);
    }));
    it('should work ok if it is url passed', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => false);
        openapi_core_1.isAbsoluteUrl.mockImplementation(() => true);
        const apisConfig = {
            apis: {
                main: {
                    root: 'https://someLinkt/petstore.yaml?main',
                    styleguide: {},
                },
            },
        };
        const result = yield utils_1.getFallbackApisOrExit(undefined, apisConfig);
        expect(process.stderr.write).toHaveBeenCalledTimes(0);
        expect(process.exit).toHaveBeenCalledTimes(0);
        expect(result).toStrictEqual([
            {
                alias: 'main',
                path: 'https://someLinkt/petstore.yaml?main',
            },
        ]);
    }));
});
describe('langToExt', () => {
    it.each([
        ['php', '.php'],
        ['c#', '.cs'],
        ['shell', '.sh'],
        ['curl', '.sh'],
        ['bash', '.sh'],
        ['javascript', '.js'],
        ['js', '.js'],
        ['python', '.py'],
    ])('should infer file extension from lang - %s', (lang, expected) => {
        expect(utils_1.langToExt(lang)).toBe(expected);
    });
    it('should ignore case when inferring file extension', () => {
        expect(utils_1.langToExt('JavaScript')).toBe('.js');
    });
});
